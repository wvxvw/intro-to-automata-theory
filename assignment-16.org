# -*- fill-column: 80; org-confirm-babel-evaluate: nil -*-

#+TITLE:     Assignment 15, Authomata Theory
#+AUTHOR:    Oleg Sivokon
#+EMAIL:     olegsivokon@gmail.com
#+DATE:      <2016-01-01 Fri>
#+DESCRIPTION: Fifth assignment in the course 20440 Automata and Formal Languages
#+KEYWORDS: Automata Theory, Formal Languages, Assignment
#+LANGUAGE: en
#+LaTeX_CLASS: article
#+LATEX_HEADER: \usepackage{commath}
#+LATEX_HEADER: \usepackage{pgf}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usetikzlibrary{shapes,backgrounds}
#+LATEX_HEADER: \usepackage{marginnote}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{enumerate}
#+LATEX_HEADER: \usepackage{algpseudocode}
#+LATEX_HEADER: \usepackage{algorithm}
#+LATEX_HEADER: \usepackage{mathtools}
#+LATEX_HEADER: \usetikzlibrary{arrows,automata}
#+LATEX_HEADER: \setlength{\parskip}{16pt plus 2pt minus 2pt}
#+LATEX_HEADER: \renewcommand{\arraystretch}{1.6}
#+LATEX_HEADER: \DeclareMathOperator{\Neg}{Neg}

#+BEGIN_SRC emacs-lisp :exports none
  (setq org-latex-pdf-process
        '("latexmk -pdflatex='pdflatex -shell-escape -interaction nonstopmode' -pdf -f %f")
        org-latex-listings t
        org-src-fontify-natively t
        org-latex-custom-lang-environments '((maxima "maxima"))
        org-listings-escape-inside '("(*@" . "@*)")
        org-babel-latex-htlatex "htlatex")

  (defmacro by-backend (&rest body)
    `(cl-case (when (boundp 'backend)
                (org-export-backend-name backend))
       ,@body))
#+END_SRC

#+RESULTS:
: by-backend

#+BEGIN_LATEX
\definecolor{codebg}{rgb}{0.96,0.99,0.8}
\definecolor{codestr}{rgb}{0.46,0.09,0.2}
\lstset{%
  backgroundcolor=\color{codebg},
  basicstyle=\ttfamily\scriptsize,
  breakatwhitespace=false,
  breaklines=false,
  captionpos=b,
  framexleftmargin=10pt,
  xleftmargin=10pt,
  framerule=0pt,
  frame=tb,
  keepspaces=true,
  keywordstyle=\color{blue},
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  stringstyle=\color{codestr},
  tabsize=2
}
\lstnewenvironment{maxima}{%
  \lstset{%
    backgroundcolor=\color{codebg},
    escapeinside={(*@}{@*)},
    aboveskip=20pt,
    captionpos=b,
    label=,
    caption=,
    showstringspaces=false,
    frame=single,
    framerule=0pt,
    basicstyle=\ttfamily\scriptsize,
    columns=fixed}}{}
}
\makeatletter
\newcommand{\verbatimfont}[1]{\renewcommand{\verbatim@font}{\ttfamily#1}}
\makeatother
\verbatimfont{\small}%
\clearpage
#+END_LATEX

* Problems

** Problem 1
   Given context-free grammar $V = \{S,M,N,W,X,Y,Z\}$ s.t. $T=\{1,0\}$
   
   #+HEADER: :exports results
   #+HEADER: :results (by-backend (pdf "latex") (t "raw"))
   #+BEGIN_SRC latex
     \begin{align*}
       &S \to M \;|\; XN \;|\; W \;|\; 0N \;|\; 1Z1 \\
       &M \to 0M0 \;|\; N \\
       &N \to N0 \;|\; 0 \\
       &W \to 0W \;|\; 00W0 \\
       &X \to 0X1 \;|\; 0 \;|\; 0Y0 \\
       &Z \to W \;.
     \end{align*}
   #+END_SRC
   
   1. Is $V$ ambiguous?
   2. Give a normalized grammar equivalent to $V$.

*** Answer 2
    It is easier to normalize the grammar first and then to look for ambiguities,
    thus the answers are in reverse order.
    1. Any derivation containing $W$ cannot terminate, and so does $Z$.
    2. Further, we can eliminate the rule $M \to N$.
    3. $Y$ has no derivation rules, thus we can also remove it.
       
    Thus obtaining:
    #+HEADER: :exports results
    #+HEADER: :results (by-backend (pdf "latex") (t "raw"))
    #+BEGIN_SRC latex
      \begin{align*}
        &S \to M \;|\; XM \;|\; 0M \\
        &M \to 0M0 \;|\; 0 \;|\; 0M \\
        &X \to 0X1 \;|\; 0 \;.
      \end{align*}
    #+END_SRC

    1. It is easy to see that $M$ derives number of zeros greater than one,
       thus $M \to 0M0$ is redundant.  Subsequently, $S \to 0M$ is already
       covered by $S \to M$.
       
       
    What remains is:
    #+HEADER: :exports results
    #+HEADER: :results (by-backend (pdf "latex") (t "raw"))
    #+BEGIN_SRC latex
      \begin{align*}
        &S \to M \;|\; XM \\
        &M \to 0 \;|\; 0M \\
        &X \to 0 \;|\; 0X1 \;.
      \end{align*}
    #+END_SRC

*** Answer 1
    Now it is easy to see that the string 00 can be derived in two different
    ways:

    + $S \to M$, $M \to 0M$, $M \to 0$.
    + $S \to XM$, $X \to 0$, $M \to 0$.
      
    Hence $V$ is ambiguous.
** Problem 2
   Given context-free grammar $V = \{S,M,N,W,X,Y,Z\}$ s.t. $T=\{1,0\}$
   
   #+HEADER: :exports results
   #+HEADER: :results (by-backend (pdf "latex") (t "raw"))
   #+BEGIN_SRC latex
     \begin{align*}
       &S \to 0W11 \;|\; 0X1 \;|\; 0Y \\
       &W \to S \;|\; Z \\
       &X \to S \;|\; W \\
       &Y \to 1 \\
       &Z \to X \;.
     \end{align*}
   #+END_SRC
   
   1. Bring $V$ to Chomsky's normal form.
   2. What is the language of $V$?

*** Answer 3
    1. We can easily eliminate $Y$ variable, thus removing $Y \to 1$ rule,
       and adding $S \to 01$ rule.
    2. We can eliminate $Z$ variable by removing $Z \to X$ and $W \to Z$ rules
       and adding $W \to X$ rule.
    3. We can eliminate $X$ variable by removing $X \to S \;|\; W$ and $S \to
       0X1$ rules, and adding: $S \to 0S1$ rule.
    4. Finally, we can eliminate $W$ variable by removing $W \to S$ and $S \to
       0W11$ rules and adding $S \to 0S11$ rule.
       
       
    The resulting grammar will be:
    
    #+HEADER: :exports results
    #+HEADER: :results (by-backend (pdf "latex") (t "raw"))
    #+BEGIN_SRC latex
      \begin{align*}
        &S \to 0S11 \;|\; 0S1 \;|\; 01 \;.
      \end{align*}
    #+END_SRC
    
    Since this is still not CNF, I introduce an extra variable: $X$ and
    derivation rules $X \to 0$, $Y \to 1 \;|\; 11$ and $Z \to SY$ thus
    obtaining:
    
    #+HEADER: :exports results
    #+HEADER: :results (by-backend (pdf "latex") (t "raw"))
    #+BEGIN_SRC latex
      \begin{align*}
        &S \to XZ \;|\; 01 \\
        &X \to 0 \\
        &Y \to 1 \;|\; 11 \\
        &Z \to SY \;.
      \end{align*}
    #+END_SRC
    
    Which is in CNF.

*** Answer 4
    Using the results from the previous answer it is easy to see that
    the language $L(V)=\{0^n1^k \;|\; n \leq k \land n,k > 0\}$.

** Problem 3
   Build a PDA accepting the language $L$ by emptying the stack.

   #+HEADER: :exports results
   #+HEADER: :results (by-backend (pdf "latex") (t "raw"))
   #+BEGIN_SRC latex
     \begin{align*}
       L = \{ a^{i_1}b^{j_1}a^{i_2}b^{j_2}\dots a^{i_m}b^{j_m}
            &\;|\; m \geq 1 \\
            &\;|\; \forall k: i_k \geq j_k \geq 1 \\
            &\;|\; \exists k: i_k > j_k \}
     \end{align*}
   #+END_SRC

*** Answer 5
    First, I'll write the grammar for $L$ (because it's easier to do):

    #+HEADER: :exports results
    #+HEADER: :results (by-backend (pdf "latex") (t "raw"))
    #+BEGIN_SRC latex
      \begin{align*}
        &S \to aSb \;|\; K \;|\; SS \\
        &K \to aKb \;|\; aaKb \\
        &X \to aXb \;|\; aaXb \;|\; \epsilon \;.
      \end{align*}
    #+END_SRC

    1. $X$ generates strings of the form $\{ a^nb^m \;|\; n \geq m \}$.
    2. Similarly, $K$ generates strings of the form $\{ a^nb^m \;|\; n > m \}$.
    3. The derivatin of $S$ can only terminate when it eventually derives either
       $K$.  It can repeat as many times as needed to accept the entire string.
       Where the repeated element is, again, of the form of either $\{ a^nb^m
        \;|\; n \geq m \}$, or  $\{ a^nb^m \;|\; n > m \}$.
        
    Thus, at least informally, we are convinced the grammar generates $L$.

    Now, the automaton:

    #+HEADER: :exports results
    #+HEADER: :results latex
    #+BEGIN_SRC latex
      \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,
                          semithick]

        \node[initial,state]   (A)              {$q_0$};
        \node[state]           (B) [right of=A, above of=A] {$q_1$};
        \node[state]           (C) [right of=B, below of=B] {$q_2$};
        \node[state]           (D) [below of=A] {$q_3$};
        \node[state]           (E) [right of=D] {$q_4$};
        \node[state]           (F) [right of=E] {$q_5$};
        \node[accepting,state] (G) [below of=E] {$q_6$};
        \node[state]           (H) [left of=G, below of=G] {$q_7$};
        \node[state]           (J) [right of=G, below of=G] {$q_8$};

        \path (A) edge              node {$a \to A/AA$} (B)
                  edge              node {$\epsilon$} (D)
              (B) edge [loop above] node {$a \to A/AA$} (B)
                  edge              node {$\epsilon$} (C)
              (C) edge [loop above] node {$b \to A/A$} (C)
                  edge              node {$b \to Z/Z$} (A)
              (D) edge              node {$a \to A/AA$} (E)
              (E) edge [loop above] node {$a \to A/AA$} (E)
                  edge              node {$\epsilon \to A/A$} (F)
              (F) edge [loop above, align=center] node {$b \to A/A$ \\ $\epsilon \to A/A$} (F)
                  edge              node {$b \to Z/Z$} (G)
              (G) edge              node {$\epsilon$} (H)
              (H) edge [loop below] node {$a \to A/AA$} (G)
                  edge              node {$\epsilon$} (J)
              (J) edge [loop below, align=center] node {$\epsilon \to A/A$ \\ $b \to A/A$} (J)
                  edge              node {$\epsilon \to Z/Z$} (G);
      \end{tikzpicture}
    #+END_SRC

    The idea behind this diagram is as follows:
    1. Loop as many times as needed (possibly zero) over strings $a^nb^n$, where
       $n \geq 1$.
    2. Nondeterministically parse a string $a^nb^m$ where $n > m$.
    3. Loop as many times as needed (possibly zero) over strings $a^nb^m$ where
       $n \geq m$.
    4. Before accepting state, keep discarding $A$ until none remain for as long as
       you don't see an $a$.
    5. Accept the string.
